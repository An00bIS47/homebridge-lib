// homebridge-lib/lib/TypeParser.js
//
// Library for Homebridge plugins.
// Copyright Â© 2018-2019 Erik Baauw. All rights reserved.

'use strict'

const debug = require('debug')('TypeParser')
const events = require('events')

debug('module loading...')

// Standard types.
const Types = [
  'any', 'boolean', 'integer', 'number', 'string',
  'array', 'object', 'function', 'instance', 'class'
]

// Create object with the standard types, so clients can refer to
// TypeParser.Type.any, TypeParser.Type.boolean, etc.
const Type = {}
for (const type of Types) {
  Type[type] = type
}
Object.freeze(Type)

// Validate options.
function toOptions (type, options) {
  if (Types.includes(type)) {
    options = Object.assign({ type: type }, options)
  }
  if (options._validated) {
    delete options._validated
    return options
  }
  if (Object.keys(options).length > 0) {
    options = baseParser._parseDefinition(
      options, { strict: true, userInput: false, _key: 'options' }
    )
  }
  return options
}

// Add property key to options.
function keyOptions (key, options) {
  const _key = options._key == null
    ? key
    : options._key + '.' + key
  return Object.assign({}, options, { _key: _key })
}

// Add array index to options.
function idOptions (id, options) {
  const _key = options._key == null
    ? '[' + id + ']'
    : options._key + '[' + id + ']'
  return Object.assign({}, options, { _key: _key })
}

/** Parser and validator for value types.
  * See the {@tutorial TypeParser} tutorial.
  *
  * `TypeParser` parses values of expressions or variables, validating whether
  * they are of the appropriate value type.
  * These values might be input by a user (e.g. homebridge's `config.json`), or
  * generated by a program (e.g. the `options` parameter to a function).
  * `TypeParser` helps to identify bugs, undetected because of Javascript's
  * [weak typing](https://en.wikipedia.org/wiki/Strong_and_weak_typing).
  *
  * `TypeParser` pre-defines a number of standard value types.
  * It also provides a mechanism to define custom value types.
  *
  * {@link TypeParser.Type Type} lists the standard value types.
  * For each of these, `TypeParser` provides a corresponding class method,
  * `to`_Type_`()`. This method takes two parameters, `value` and
  * `options`.  It returns the value converted to the corresponding `Type`,
  * or throws an error.  The options modify the conversion logic.
  *
  * `TypeParser` defines the following standard types:
  *
  * type       | parser                                     | description
  * ---------- | ------------------------------------------ | -----------
  * `any`      | {@link TypeParser.toAny toAny()}           | Any "real" value, not `undefined` or `null`.
  * `boolean`  | {@link TypeParser.toBoolean toBoolean()}   | A `boolean`.
  * `integer`  | {@link TypeParser.toInteger toInteger()}   | A `number` with an integer value.
  * `number`   | {@link TypeParser.toNumber toNumber()}     | A `number` with a "real" value, not `Infinity` or `NaN`.
  * `string`   | {@link TypeParser.toString toString()}     | A `string`.
  * `array`    | {@link TypeParser.toArray toArray()}       | An array.
  * `object`   | {@link TypeParser.toObject toObject()}     | An object.
  * `function` | {@link TypeParser.toFunction toFunction()} | A function.
  * `instance` | {@link TypeParser.toInstance toInstance()} | An instance of a class, created through `new `_Class_`()`.
  * `class`    | {@link TypeParser.toClass toClass()}       | A class, defined through `class `_Class_.
  *
  * Note the `Type` itself is actually a `string`.
  *
  * A custom value type is an object with well-defined properties (key/value
  * pairs), like the contents of `config.json` or an `options` parameter.
  * It is defined through an object containing the same keys as the
  * custom value type, with an associated {@link TypeParser.Definition
  * Definition} as value.
  * These definitions are passed to the constructor to create a corresponding
  * parser.
  * This parser is called through the {@link TypeParser#parse parse()} method.
  * Like the `to`_Type_`()` class methods, it takes two parameters,
  * `value` and `options`.  It returns converted value, or throws an error.
  *
  * Note that `Definition` itself actually defines a custom value type:
  * the definitions for a custom value type.
  *
  * By default, the parsers convert the value into the requested specifciation
  * where possible.  When `options.strict` is set, the value must match the
  * specification strictly.
  *
  * By default, the parsers throw a `TypeError` or `RangeError`
  * when the value doesn't or cannot be converted to match the specification.
  * When `options.userInput` is set, the parsers throw a
  * {@link TypeParser.UserInputError UserInputError} instead.
  * Note that even with this setting, the parsers can throw other errors
  * for invalid `options`, as these are not input by the user.
  */
class TypeParser extends events.EventEmitter {
  /** Class for a user input error.
    * @class
    * @extends Error
    * @noconstructor
    */
  static get UserInputError () {
    return class UserInputError extends Error {
      constructor (message) {
        super(message)
        this.name = 'UserInputError'
      }
    }
  }

  // Throw a TypeError or UserInputError, depending on options.userInput.
  _throwTypeError (message, options) {
    if (options._key != null) {
      message = options._key + ': ' + message
    }
    const error = options.userInput === true
      ? new TypeParser.UserInputError(message)
      : new TypeError(message)
    this.emit('error', error)
    throw error
  }

  // Throw a RangeError or UserInputError, depending on options.userInput.
  _throwRangeError (message, options) {
    if (options._key != null) {
      message = options._key + ': ' + message
    }
    const error = options.userInput === true
      ? new TypeParser.UserInputError(message)
      : new RangeError(message)
    this.emit('error', error)
    throw error
  }

  // Issue debug message for calling a function f().
  _call (f, value, options) {
    const key = options._key == null ? '' : options._key + ': '
    debug('%d%s %s%s(%o, %o)', this._id, this._prefix, key, f, value, options)
    // debug('%d%s %s%s(%o)', this._id, this._prefix, key, f, value)
    this._prefix += '  '
  }

  // Issue debug message for returning from a function.
  _return (value) {
    this._prefix = this._prefix.substring(2)
    debug('%d%s => %o', this._id, this._prefix, value)
  }

  /** Pre-defined value type.
    * @typedef
    * @property {string} any - Any "real" value, not `undefined` or `null`.
    * @property {string} boolean - A `boolean`.
    * @property {string} integer - A `number` with an integer value.
    * @property {string} number - A `number` with a "real" value, not `Infinity` or `NaN`.
    * @property {string} string - A `string`.
    * @property {string} array - An array.
    * @property {string} object - An object.
    * @property {string} function - A function.
    * @property {string} instance - An instance of a class, created through `new `_Class_`()`.
    * @property {string} class - A class, defined through `class `_Class_.
    */
  static get Type () {
    return Type
  }

  /** Pre-defined patterns.
    * @typedef
    * @property {RegExp} hostname - A hostname.
    * @property {RegExp} integer2 - A binary integer.
    * @property {RegExp} integer8 - An octal integer.
    * @property {RegExp} integer10 - A decimal integer.
    * @property {RegExp} integer16 - A hexadecimal integer.
    * @property {RegExp} ipv4 - An IPv4 address.
    // * @property {RegExp} ipv6- An IPv6 address.
    * @property {RegExp} mac - An 48-bits EUI-48 MAC address.
    * @property {RegExp} mac64 - An 64-bits EUI-64 MAC address.
    * @property {RegExp} number - A number.
    */
  static get Pattern () {
    return Object.freeze({
      hostname: /^[a-zA-Z](:?[a-zA-Z0-9-]*[a-zA-Z0-9])*$/,
      integer2: /^\s*([+-]?)(?:0[bB])?([01]+)\s*$/,
      integer8: /^\s*([+-]?)(?:0[oO])?([0-8]+)\s*$/,
      integer10: /^\s*([+-]?)([0-9]+(?:\.0*)?)\s*$/,
      integer16: /^\s*([+-]?)(?:0[xX])?([0-9A-Fa-f]+)\s*$/,
      ipv4: /^(\d{1,2}|[01]\d{2}|2[0-4]\d|25[0-5])\.(\d{1,2}|[01]\d{2}|2[0-4]\d|25[0-5])\.(\d{1,2}|[01]\d{2}|2[0-4]\d|25[0-5])\.(\d{1,2}|[01]\d{2}|2[0-4]\d|25[0-5])$/,
      mac: /^([0-9a-fA-F]{1,2})[:-]([0-9a-fA-F]{1,2})[:-]([0-9a-fA-F]{1,2})[:-]([0-9a-fA-F]{1,2})[:-]([0-9a-fA-F]{1,2})[:-]([0-9a-fA-F]{1,2})$/,
      mac64: /^([0-9a-fA-F]{1,2})[:-]([0-9a-fA-F]{1,2})[:-]([0-9a-fA-F]{1,2})[:-]([0-9a-fA-F]{1,2})[:-]([0-9a-fA-F]{1,2})[:-]([0-9a-fA-F]{1,2})[:-]([0-9a-fA-F]{1,2})[:-]([0-9a-fA-F]{1,2})$/,
      number: /^\s*[+-]?(?:[0-9]*(?:\.[0-9]+)?|[0-9]+\.[0-9]*)(?:[eE][+-]?[0-9]+)?\s*$/
    })
  }

  /** Definition of a property value for a custom value type.
    * @typedef
    * @property {TypeParser.Type} type - The value type of the property.
    * @property {boolean} [mandatory] - The property is mandatory.
    * @property {boolean} [strict] - Strict validation.<br>
    * @property {*} [defaultValue] - The default value for the property.
    * @property {integer|number} [minimumValue] - Minimum value.<br>
    * Valid for types: `integer`, `number`.
    * @property {integer|number} [maximumValue] - Maximum value.<br>
    * Valid for types: `integer`, `number`.
    * @property {boolean} [nonEmpty=false] - Property must no be empty.<br>
    * Valid for types: `string`, `array`, `object`.
    * @property {enum} [case] - Case (`lower` or `upper`).<br>
    * Valid for types: `string`.
    * @property {object} [enumValues] - Allowed enum values.<br>
    * Must be a non-empty array with unique, non-empty `string` values.<br>
    * Mandatory and valid for type: `enum`.
    * @property {boolean} [asString=false] - Value is returned as `string`.<br>
    * Valid for types: `host`, `path`.
    * @property {boolean} [absolute=false] - Path must start with a `/`.<br>
    * Valid for types: `path`.
    * @property {boolean} [membersNonEmpty] - Members must not be empty.<br>
    * Valid for types: `array`, `object`.
    * @property {TypeParser.Type} [membersType] - Mandatory type for
    * members.<br>
    * Valid for types: `array`, `object`.
    * @property {boolean} [membersUnique] - Discard duplicate array members.<br>
    * Valid for type: `array`.
    * @property {class} [Class] - Class for an instance property or
    * superclass for a class property.<br>
    * Valid for types: `instance`, `class`.
    */
  static get Definition () { return {} }

  /** Parse a value for an `any` value type.
    * @param {*} value - Value to parse.
    *
    * Default validation:
    * - Throws a `TypeError` for `undefined` or `null`;
    * - Returns any "real" value.
    * @param {object} [options]
    * @param {boolean} [options.strict=false] - Strict validation:
    * - Same as normal validation.
    * @param {*} [options.defaultValue] - Default value:
    * - Returned for `undefined` or `null`, instead of throwing a `TypeError`.
    * @param {boolean} [options.userInput=false] - Value was input by user:
    * - Throw `UserInputError` instead of `TypeError`.
    * @returns {*} A "real" value, not `undefined` or `null`.
    * @throws `TypeError` - When value is `undefined` or `null`.
    * @throws `UserInputError` - On error, when `options.userInput` is set.
    */
  static toAny (value, options = {}) {
    return baseParser._parseType(value, toOptions('any', options))
  }

  /** Parse a value for a `boolean` value type.
    * @param {*} value - Value to parse.
    *
    * Default validation:
    * - Throws a `TypeError` for `undefined` or `null`;
    * - Returns a `boolean` value;
    * - Returns `false` for `number` value `0`;
    * - Returns `true` for `number` value `1`;
    * - Returns `false` for `string` values `'false'`, `'no'`, or `'0'`;
    * - Returns `true` for `string` values `'true'`, `'yes'`, or `'1'`;
    * - Throws a `TypeError` for any other value;
    * @param {object} [options]
    * @param {boolean} [options.strict=false] - Strict validation:
    * - Throws a `TypeError` for any `number` or `string` value.
    * @param {boolean} [options.defaultValue] - Default value:
    * - Returned for `undefined` or `null`, instead of throwing a `TypeError`.
    * @param {boolean} [options.userInput=false] - Value was input by user:
    * - Throw `UserInputError` instead of `TypeError`.
    * @returns {boolean} A `boolean` value.
    * @throws `TypeError` - When value cannot be converted to `boolean`.
    * @throws `UserInputError` - On error, when `options.userInput` is set.
    */
  static toBoolean (value, options = {}) {
    return baseParser._parseType(value, toOptions('boolean', options))
  }

  /** Parse a value for an `integer` value type.
    * @param {*} value - Value to parse.
    *
    * Default validation:
    * - Throws a `TypeError` for `undefined` or `null`;
    * - Returns `0` for `false` and `1` for `true`;
    * - Returns any integer `number` value between the minimum and maximum
    * values;
    * - Throws a `RangeError` for any integer value smaller (greater) than
    * the minimum (maximum) value.
    * - Throws a `TypeError` for any non-integer number value,
    * including `NaN`, `-Infinity`, and `Infinity`;
    * - Converts a `string` value holding an integer;
    * - Throws a `TypeError` for any other value.
    * @param {object} [options]
    * @param {boolean} [options.strict=false] - Strict validation:
    * - Throws a `RangerError` for any value less than `options.minimumValue`
    * (greater than `options.maximumValue`), instead of returning the
    * minimum (maximum) value.
    * - Throws a `TypeError` for any `boolean` or `string` value.
    * @param {integer} [options.defaultValue] - Default value:
    * - Returned for `undefined` or `null`, instead of throwing a `TypeError`.
    * @param {integer} [options.minimumValue] - Minimum value:
    * - Returned when value is less than minimum value.
    * @param {integer} [options.maximumValue] - Maximum value:
    * - Returned when value is greater than maximum value.
    * @param {boolean} [options.userInput=false] - Value was input by user:
    * - Throw `UserInputError` instead of `TypeError` or `RangeError`.
    * @returns {integer} An `integer` value.
    * @throws `TypeError` - When value cannot be converted to `integer`.
    * @throws `RangeError` - When value is less (greater) than minimum (maximum)
    * value (stric validation).
    * @throws `UserInputError` - On error, when `options.userInput` is set.
    */
  static toInteger (value, options = {}) {
    return baseParser._parseType(value, toOptions('integer', options))
  }

  /** Parse a value for a `number` value type.
    * @param {*} value - Value to parse.
    *
    * Default validation:
    * - Throws a `TypeError` for `undefined` or `null`;
    * - Returns `0` for `false` and `1` for `true`;
    * - Returns any `number` value between the minimum and maximum values;
    * - Throws a `RangeError` for any number value smaller (greater) than
    * the minimum (maximum) value.
    * - Throws a `TypeError` for any non-finite number value,
    * `NaN`, `-Infinity`, or `Infinity`;
    * - Converts a `string` value holding a number;
    * - Throws a `TypeError` for any other value.
    * @param {object} [options]
    * @param {boolean} [options.strict=false] - Strict validation:
    * - Throws a `RangerError` for any value less than `options.minimumValue`
    * (greater than `options.maximumValue`), instead of returning the
    * minimum (maximum) value.
    * - Throws a `TypeError` for any `boolean` or `string` value.
    * @param {number} [options.defaultValue] - Default value:
    * - Returned for `undefined` or `null`, instead of throwing a `TypeError`.
    * @param {number} [options.minimumValue] - Minimum value:
    * - Returned when value is less than minimum value.
    * @param {number} [options.maximumValue] - Maximum value:
    * - Returned when value is greater than maximum value.
    * @param {boolean} [options.userInput=false] - Value was input by user:
    * - Throw `UserInputError` instead of `TypeError` or `RangeError`.
    * @returns {number} A `number` value.
    * @throws `TypeError` - When value cannot be converted to `integer`.
    * @throws `RangeError` - When value is less (greater) than minimum (maximum)
    * value (stric validation).
    * @throws `UserInputError` - On error, when `options.userInput` is set.
    */
  static toNumber (value, options = {}) {
    return baseParser._parseType(value, toOptions('number', options))
  }

  /** Parse a value for a `string` value type.
    * @param {*} value - Value to parse.
    *
    * Default validation:
    * - Throws a `TypeError` for `undefined` or `null`;
    * - Returns a `boolean` or `number` value converted to `string`;
    * - Returns a `string` value;
    * - Returns any other value converted to a `string`, using its
    * `toString()` method.
    * - Throws a `TypeError` for any other value without a `toString()` method.
    * @param {object} [options]
    * @param {boolean} [options.strict=false] - Strict validation:
    * - Throws a `TypeError` for any non-`string` value;
    * - Throws a `RangeError` for `string` value in wrong case.
    * @param {string} [options.defaultValue] - Default value:
    * - Returned for `undefined` or `null`, instead of throwing a `TypeError`.
    * @param {boolean} [options.nonEmpty] - Non-empty string:
    * - Throws a `RangeError` for an empty string.
    * @param {enum} [options.case] - Case (`lower` or `upper`):<br>
    * - Casts string to lower or upper case.
    * @param {boolean} [options.userInput=false] - Value was input by user:
    * - Throw `UserInputError` instead of `TypeError` or `RangeError`.
    * @returns {number} A `string` value.
    * @throws `TypeError` - When value cannot be converted to `string`.
    * @throws `RangeError` - When value is `''` and `options.nonEmpty` is set.
    * @throws `UserInputError` - On error, when `options.userInput` is set.
    */
  static toString (value, options = {}) {
    return baseParser._parseType(value, toOptions('string', options))
  }

  /** Parse a value for an `array` value type.
    * @param {*} value - Value to parse.
    * @param {object} [options]
    * @returns {array} An `array` value.
    */
  static toArray (value, options = {}) {
    return baseParser._parseType(value, toOptions('array', options))
  }

  /** Parse a value for an `object` value type.
    * @param {*} value - Value to parse.
    * @param {object} [options]
    * @returns {object} An `object` value.
    */
  static toObject (value, options = {}) {
    return baseParser._parseType(value, toOptions('object', options))
  }

  /** Parse a value for a `function` value type.
    * @param {*} value - Value to parse.
    * @param {object} [options]
    * @returns {function} A function` value.
    */
  static toFunction (value, options = {}) {
    return baseParser._parseType(value, toOptions('function', options))
  }

  /** Parse a value for an `instance` value type.
    * @param {*} value - Value to parse.
    * @param {object} [options]
    * @returns {instance} An `instance` value.
    */
  static toInstance (value, options = {}) {
    return baseParser._parseType(value, toOptions('instance', options))
  }

  /** Parse a value for a `class` value type.
    * @param {*} value - Value to parse.
    * @param {object} [options]
    * @returns {Class} A `class` value.
    */
  static toClass (value, options = {}) {
    return baseParser._parseType(value, toOptions('class', options))
  }

  /** Create a new parser for a custom value type.
    *
    * @param {!Object.<string, TypeParser.Definition>} definitions -
    * Specification of the properties of the
    * custom value type.  Each key in this object defines the key of a
    * property.  The corresponding value holds the
    * {@link TypeParser.Definition Definition} of the
    * property's value.
    * @param {object} [options]
    * @param {boolean} [options.strict=false] - Default value for `strict` of
    * each property definition.  Can be overwritten in the property definition.
    * @param {boolean} [options.otherKeys=false] - Allow other keys than the
    * ones specified.  The corresponding values will be checked as `any`.
    */
  constructor (definition = {}) {
    super()
    this._prefix = ''
    this._id = ++instanceId
    this._definition = toOptions('definition', definition)
  }

  /** Parse a value of a custom value type.
    * @param {*} value - Value to parse.
    *
    * Normal validation:
    * - Throws a `TypeError` when value is not an `object`;
    * - Throws a `TypeError` for a missing property with a mandatory key,
    * without a default value;
    * - Throws a `TypeError` for a property with an invalid key;
    * - Throws a `TypeError` when a property has a value of the wrong type;
    * - Throws a `RangeEror` when a property has an invalid value;
    * - Returns object with converted values and added keys for default
    * values.
    *
    * When detecting an error, an `error` event is emitted and validation of
    * the remaining key/value pairs continues (possibly causing more `error`)
    * events.
    * After all key/value pairs have been validated, the first error is thrown.
    * @param {object} [options]
    * @param {boolean} [options.userInput=false] - Value was input by user:
    * - Throw `UserInputError` instead of `TypeError`, or `RangeError`.
    * @returns {object} Object with converted values and added keys for default
    * values.
    * @throws `TypeError`
    * - When value is `undefined` or `null`;
    * - When value is not an `object`;
    * - When a property has in invalid key (and `options.otherKeys` wasn't set
    * when creating the parser);
    * - When a property with a mandatory key and without a default value is
    * missing; or
    * - When a property has a value of an invalid type.
    * @throws `RangeError`
    * - When a property has an invalid value.
    * @throws `UserInputError`
    * - On error, when `options.userInput` is set.
    * @emits error
    * - For each error.
    */
  parse (value, options = {}) {
    this._call('parse', value, options)
    this._prefix = ''
    let typeOptions = Object.assign({}, this._definition, options)
    typeOptions = toOptions('parse', typeOptions)
    value = this._parseType(value, typeOptions)
    this._return(value)
    return value
  }

  // Call appropriate parser for standard type or definition.
  _parseType (value, options) {
    const parserName = '_parse' +
      options.type[0].toUpperCase() + options.type.substr(1)
    this._call(parserName, value, options)
    const result = this[parserName](value, options)
    this._return(result)
    return result
  }

  _parseAny (value, options) {
    if (value == null) {
      if (
        (options.strict && value === undefined) ||
        options.defaultValue === undefined
      ) {
        const type = options.type === 'any' ? '' : options.type + ' '
        this._throwTypeError(`missing ${type}value`, options)
      }
      value = options.defaultValue
    }
    return value
  }

  _parseBoolean (value, options) {
    value = this._parseAny(value, options)
    if (value == null) {
      return value
    }
    if (!options.strict) {
      if (typeof value === 'string') {
        value = value.toLowerCase()
      }
      if (value === 'false' || value === 'no' || value === '0' || value === 0) {
        return false
      }
      if (value === 'true' || value === 'yes' || value === '1' || value === 1) {
        return true
      }
    }
    if (typeof value !== 'boolean') {
      if (options.strict || options.defaultValue === undefined) {
        this._throwTypeError('not a boolean', options)
      }
      value = options.defaultValue
    }
    return value
  }

  _checkNumberValues (value, options) {
    if (value < options.minimumValue) {
      if (options.strict || options.strictRange) {
        this._throwRangeError(`invalid ${options.type} value: below ${options.minimumValue}`, options)
      }
      return options.minimumValue
    }
    if (value > options.maximumValue) {
      if (options.strict || options.strictRange) {
        this._throwRangeError(`invalid ${options.type} value: above ${options.maximumValue}`, options)
      }
      return options.maximumValue
    }
    if (options.allowedValues != null) {
      let largestAllowed
      for (let allowed of options.allowedValues) {
        if (typeof allowed === 'number') {
          allowed = [ allowed, allowed ]
        }
        largestAllowed = allowed[1]
        if (value < allowed[0]) {
          if (options.strict || options.strictRange) {
            this._throwRangeError(`invalid ${options.type} value: not in allowed values`, options)
          }
          return allowed[0]
        }
        if (allowed[0] <= value && value <= allowed[1]) {
          return value
        }
      }
      if (options.strict || options.strictRange) {
        this._throwRangeError(`invalid ${options.type} value: not in allowed values`, options)
      }
      return largestAllowed
    }
    return value
  }

  _parseInteger (value, options) {
    value = this._parseAny(value, options)
    if (value == null) {
      return value
    }
    options.radix = options.radix || 10
    if (!options.strict) {
      if (typeof value === 'boolean') {
        value = value ? 1 : 0
      }
      const pattern = TypeParser.Pattern['integer' + options.radix]
      if (typeof value === 'string' && pattern.test(value)) {
        const array = pattern.exec(value)
        value = array[1] + array[2] // sign and digits, discard prefix
        value = parseInt(value, options.radix)
      }
    }
    if (typeof value !== 'number' || parseInt(value) !== value) {
      if (options.strict || options.defaultValue === undefined) {
        this._throwTypeError('not an integer', options)
      }
      value = options.defaultValue
    }
    value = this._checkNumberValues(value, options)
    if (!options.asString) {
      return value
    }
    value = value.toString(options.radix).toUpperCase()
    if (options.length !== null) {
      value = ('0'.repeat(options.length - 1) + value).substr(-options.length)
    }
    return value
  }

  _parseNumber (value, options) {
    value = this._parseAny(value, options)
    if (value == null) {
      return value
    }
    if (!options.strict) {
      if (typeof value === 'boolean') {
        value = value ? 1 : 0
      }
      if (typeof value === 'string' && TypeParser.Pattern.number.test(value)) {
        value = parseFloat(value, options.radix)
      }
    }
    if (typeof value !== 'number' || !Number.isFinite(value)) {
      this._throwTypeError('not a number', options)
    }
    value = this._checkNumberValues(value, options)
    if (!options.asString) {
      return value
    }
    if (options.length !== null) {
      const decimals = 10 * (options.length % 1)
      const length = Math.floor(options.length) + 1 + decimals
      value = Number(value).toFixed(decimals)
      value = ('0'.repeat(length - 1) + value).substr(-length)
      // value = value.substring(value.length - length)
    }
    return value
  }

  _parseString (value, options) {
    value = this._parseAny(value, options)
    if (value == null) {
      return value
    }
    if (!options.strict) {
      if (typeof value === 'boolean' || typeof value === 'number') {
        value = '' + value
      }
    }
    if (typeof value !== 'string') {
      if (options.strict || options.defaultValue === undefined) {
        this._throwTypeError('not a string', options)
      }
      value = options.defaultValue
    }
    if (options.nonEmpty && value === '') {
      this._throwRangeError('invalid empty string', options)
    }
    if (options.separator == null) {
      return value
    }
    value = value.split(options.separator)
    const arrayOptions = Object.assign({}, options, { type: 'array' })
    value = this._parseType(value, arrayOptions)
    if (options.asString) {
      value = value.join(options.separator)
    }
    return value
  }

  _parseArray (value, options) {
    if (!options.strict) {
      if (value == null) {
        value = []
      } else if (!Array.isArray(value)) {
        value = [value]
      }
    }
    value = this._parseAny(value, options)
    if (value == null) {
      return value
    }
    if (!Array.isArray(value)) {
      this._throwTypeError('not an array')
    }
    if (options.length && value.length !== options.length) {
      this._throwRangeError('invalid number of elements', options)
    }
    const result = []
    for (const id in value) {
      const _key = options._key == null
        ? '[' + id + ']'
        : options._key + '[' + id + ']'
      const keyOptions = Object.assign({}, options, { _key: _key })
      if (options.elements != null && id < options.elements.length) {
        let foundElement = false
        for (const element of options.elements[id]) {
          try {
            const parseOptions = Object.assign({}, element, { _key: _key })
            result.push(this._parseType(value[id], parseOptions))
            foundElement = true
            break
          } catch (error) {
            if (options.elements[id].length === 1) {
              throw (error)
            }
            this._return(error.toString())
          }
        }
        if (!foundElement) {
          this._throwTypeError('invalid type', keyOptions)
        }
      } else if (options.members == null) {
        result.push(value[id])
      } else {
        let foundMember = false
        for (const member of options.members) {
          try {
            const parseOptions = Object.assign({}, member, { _key: _key })
            result.push(this._parseType(value[id], parseOptions))
            foundMember = true
            break
          } catch (error) {
            if (options.members.length === 1) {
              throw (error)
            }
            this._return(error.toString())
          }
        }
        if (!foundMember) {
          this._throwTypeError('invalid type', keyOptions)
        }
      }
    }
    return result
  }

  _parseObject (value, options) {
    value = this._parseAny(value, options)
    if (value == null) {
      return value
    }
    const result = {}
    if (typeof value !== 'object' || value.constructor.name !== 'Object') {
      this._throwTypeError('not an object', options)
    }
    for (const key in value) {
      const _key = options._key == null
        ? key
        : options._key + '.' + key
      const keyOptions = Object.assign({}, options, { _key: _key })
      if (options.properties == null || options.properties[key] == null) {
        if (options.members == null) {
          this._throwTypeError('invalid key', keyOptions)
        }
        let foundMember = false
        for (const member of options.members) {
          try {
            const parseOptions = Object.assign({}, member, { _key: _key })
            result[key] = this._parseType(value[key], parseOptions)
            foundMember = true
            break
          } catch (error) {
            if (options.members.length === 1) {
              throw (error)
            }
            this._return(error.toString())
          }
        }
        if (!foundMember) {
          this._throwTypeError('invalid type', keyOptions)
        }
      } else {
        const parseOptions = Object.assign({}, options.properties[key], { _key: _key })
        result[key] = this._parseType(value[key], parseOptions)
      }
    }
    for (const key in options.properties) {
      if (options.properties[key].mandatory) {
        const _key = options._key == null
          ? key
          : options._key + '.' + key
        if (result[key] === undefined) {
          if (options.properties[key].defaultValue === undefined) {
            const keyOptions = Object.assign({}, options, { _key: _key })
            this._throwTypeError('missing key', keyOptions)
          }
          result[key] = options.properties[key].defaultValue
        }
      }
    }
    return result
  }

  _parseFunction (value, options) {
    value = this._parseAny(value, options)
    if (value == null) {
      return value
    }
    if (typeof value !== 'function') {
      this._throwTypeError('not a function', options)
    }
    if (options.strict && value.toString().substring(0, 9) !== 'function ') {
      this._throwTypeError('not a function', options)
    }
    return value
  }

  _parseInstance (value, options) {
    value = this._parseAny(value, options)
    if (value == null) {
      return value
    }
    if (
      typeof value !== 'object' || value == null ||
      typeof value.constructor !== 'function' ||
      ['Object', 'Array', 'Function'].includes(value.constructor.name)
    ) {
      this._throwTypeError('not an instance', options)
    }
    if (options.class != null) {
      if (typeof options.class !== 'function') {
        this._throwTypeError('class: not a class or function', options)
      }
      if (!(value instanceof options.class)) {
        this._throwTypeError(`not an instance of ${options.class.name}`, options)
      }
    }
    return value
  }

  _parseClass (value, options) {
    value = this._parseAny(value, options)
    if (value == null) {
      return value
    }
    if (options.class != null) {
      if (typeof options.class !== 'function') {
        this._throwTypeError('class: not a class or function', options)
      }
      if (value.prototype instanceof options.class) {
        return value
      }
      if (value !== options.class) {
        this._throwTypeError(`not a subclass of ${options.class.name}`, options)
      }
    }
    if (
      typeof value !== 'function' ||
      (options.strict && value.toString().substring(0, 6) !== 'class ')
    ) {
      this._throwTypeError('not a class', options)
    }
    return value
  }

  _parseElements (value, options) {
    this._call('_parseElements', value, options)
    if (value == null) {
      this._throwTypeError('missing array value', options)
    }
    if (!Array.isArray(value)) {
      this._throwTypeError('not an array', options)
    }
    if (value.length === 0) {
      this._throwRangeError('invalid empty array', options)
    }
    const result = []
    for (const id in value) {
      result.push(this._parseMembers(value[id], idOptions(id, options)))
    }
    this._return(result)
    return result
  }

  _parseMembers (value, options) {
    this._call('_parseMembers', value, options)
    if (value == null) {
      this._throwTypeError('missing array value', options)
    }
    if (!Array.isArray(value)) {
      value = [ value ]
    }
    if (value.length === 0) {
      this._throwRangeError('invalid empty array', options)
    }
    const result = []
    for (const id in value) {
      result.push(this._parseDefinition(value[id], idOptions(id, options)))
    }
    this._return(result)
    return result
  }

  _parseProperties (value, options) {
    this._call('_parseProperties', value, options)
    if (value == null) {
      this._throwTypeError('missing object value', options)
    }
    if (typeof value !== 'object' || value.constructor.name !== 'Object') {
      this._throwTypeError('not an object', options)
    }
    if (Object.keys(value).length === 0) {
      this._throwRangeError('invalid empty object', options)
    }
    const result = {}
    for (const key in value) {
      const definitionOptions =
        Object.assign({ mandatory: { type: 'boolean' } }, options)
      result[key] = this._parseDefinition(
        value[key], keyOptions(key, definitionOptions)
      )
    }
    this._return(result)
    return result
  }

  _parseDefinition (value, options = {}) {
    this._call('_parseDefinition', value, options)
    if (value == null) {
      this._throwTypeError('missing object value')
    }
    if (typeof value !== 'object' || value.constructor.name !== 'Object') {
      this._throwTypeError('not an object', options)
    }
    if (value.type == null) {
      this._throwTypeError('missing string value', keyOptions('type', options))
    }
    if (typeof value.type !== 'string') {
      this._throwTypeError('not a string', keyOptions('type', options))
    }
    if (definitions[value.type] == null) {
    // if (!(Types.includes(value.type))) {
      this._throwTypeError('invalid type', keyOptions('type', options))
    }
    const definition = Object.assign({}, options, definitions[value.type])
    const result = {}
    for (const key in value) {
      if (definition[key] == null) {
        this._throwTypeError('invalid key', keyOptions(key, options))
      }
      const parseOptions = Object.assign({}, options, definition[key])
      result[key] =
        this._parseType(value[key], keyOptions(key, parseOptions))
      if (key === 'properties') {
        result[key] =
          this._parseProperties(value[key], keyOptions(key, options))
      } else if (key === 'members') {
        result[key] =
          this._parseMembers(value[key], keyOptions(key, options))
      } else if (key === 'elements') {
        result[key] =
          this._parseElements(value[key], keyOptions(key, options))
      }
    }
    this._checkDefinition(result, options)
    this._return(result)
    return result
  }

  _checkDefinition (result, options) {
    if (result.maximumValue < result.minimumValue) {
      this._throwRangeError(
        `invalid ${result.type} value: below ${result.minimumValue}`,
        keyOptions('maximumValue', options)
      )
    }
    if (result.defaultValue < result.minimumValue) {
      this._throwRangeError(
        `invalid ${result.type} value: below ${result.minimumValue}`,
        keyOptions('defaultValue', options)
      )
    }
    if (result.defaultValue > result.maximumValue) {
      this._throwRangeError(
        `invalid ${result.type} value: above ${result.maximumValue}`,
        keyOptions('defaultValue', options)
      )
    }
  }
}

// Definitions of base types, options, and options.
const definitions = Object.freeze({
  any: {
    type: {
      type: 'string',
      allowedValues: Types,
      defaultValue: 'any',
      mandatory: true
    },
    defaultValue: { type: 'any', strict: true, defaultValue: null },
    strict: { type: 'boolean', strict: true },
    userInput: { type: 'boolean', strict: true }
  },
  boolean: {
    type: {
      type: 'string',
      allowedValues: 'boolean',
      mandatory: true,
      defaultValue: 'boolean'
    },
    strict: { type: 'boolean' },
    defaultValue: { type: 'boolean', strict: true, defaultValue: null },
    userInput: { type: 'boolean' }
  },
  integer: {
    type: {
      type: 'string',
      allowedValues: 'integer',
      mandatory: true,
      defaultValue: 'integer'
    },
    defaultValue: { type: 'integer', strict: true, defaultValue: null },
    minimumValue: { type: 'integer' },
    maximumValue: { type: 'integer' },
    allowedValues: {
      type: 'array',
      strict: false,
      nonEmpty: true,
      members: [
        { type: 'integer' },
        { type: 'array', length: 2, members: [{ type: 'integer' }] }
      ]
    },
    radix: { type: 'integer', allowedValues: [2, 8, 10, 16], defaultValue: 10 },
    asString: { type: 'boolean' },
    length: { type: 'integer', minimumValue: 2 },
    strict: { type: 'boolean' },
    strictType: { type: 'boolean' },
    strictRange: { type: 'boolean' },
    userInput: { type: 'boolean' }
  },
  number: {
    type: {
      type: 'string',
      allowedValues: 'number',
      mandatory: true,
      defaultValue: 'number'
    },
    defaultValue: { type: 'number', strict: true, defaultValue: null },
    minimumValue: { type: 'number' },
    maximumValue: { type: 'number' },
    allowedValues: {
      type: 'array',
      strict: false,
      nonEmpty: true,
      members: [
        { type: 'number' },
        { type: 'array', length: 2, members: [{ type: 'number' }] }
      ]
    },
    asString: { type: 'boolean' },
    length: { type: 'number', minimumValue: 2 },
    strict: { type: 'boolean' },
    strictType: { type: 'boolean' },
    strictRange: { type: 'boolean' },
    userInput: { type: 'boolean' }
  },
  string: {
    type: {
      type: 'string',
      allowedValues: 'string',
      mandatory: true,
      defaultValue: 'string'
    },
    defaultValue: { type: 'string', strict: true, defaultValue: null },
    nonEmpty: { type: 'boolean' },
    allowedValues: {
      type: 'array',
      strict: false,
      nonEmpty: true,
      members: [
        { type: 'string' },
        { type: 'instance', class: RegExp }
      ]
    },
    case: { type: 'string', allowedValues: ['lower', 'upper'] },
    // length: {
    //   type: 'array',
    //   strict: false,
    //   nonEmpty: true,
    //   members: [
    //     { type: 'integer', minimumValue: 0 },
    //     { type: 'array', length: 2, members: [{ type: 'integer', minimumValue: 0 }] }
    //   ]
    // },
    length: { type: 'integer', minimumValue: 0 },
    separator: { type: 'string', length: 1 },
    members: {
      type: 'array',
      strict: false,
      nonEmpty: true,
      members: [{ type: 'any' }]
    },
    asString: { type: 'boolean' },
    strict: { type: 'boolean' },
    userInput: { type: 'boolean' }
  },
  array: {
    type: {
      type: 'string',
      allowedValues: 'array',
      mandatory: true,
      defaultValue: 'array'
    },
    defaultValue: { type: 'array', defaultValue: null },
    nonEmpty: { type: 'boolean' },
    length: { type: 'integer', minimumValue: 0 },
    members: {
      type: 'array',
      strict: false,
      nonEmpty: true,
      members: [{ type: 'any' }]
    },
    elements: {
      type: 'array',
      nonEmpty: true,
      members: [{
        type: 'array',
        strict: false,
        nonEmpty: true,
        members: [{ type: 'any' }]
      }]
    },
    strict: { type: 'boolean' },
    userInput: { type: 'boolean' }
  },
  object: {
    type: {
      type: 'string',
      allowedValues: 'object',
      mandatory: true,
      defaultValue: 'object'
    },
    defaultValue: { type: 'object', defaultValue: null },
    nonEmpty: { type: 'boolean' },
    properties: {
      type: 'object',
      nonEmpty: true,
      members: [{ type: 'any' }]
    },
    members: {
      type: 'array',
      strict: false,
      nonEmpty: true,
      members: [{ type: 'any' }]
    },
    strict: { type: 'boolean' },
    userInput: { type: 'boolean' }
  },
  function: {
    type: {
      type: 'string',
      allowedValues: 'function',
      mandatory: true,
      defaultValue: 'function'
    },
    defaultValue: { type: 'function', defaultValue: null },
    strict: { type: 'boolean' },
    userInput: { type: 'boolean' }
  },
  instance: {
    type: {
      type: 'string',
      allowedValues: 'instance',
      mandatory: true,
      defaultValue: 'instance'
    },
    strict: { type: 'boolean' },
    defaultValue: { type: 'instance', defaultValue: null },
    userInput: { type: 'boolean' },
    class: { type: 'function', strict: false }
  },
  class: {
    type: {
      type: 'string',
      allowedValues: 'class',
      mandatory: true,
      defaultValue: 'class'
    },
    defaultValue: { type: 'class', defaultValue: null },
    class: { type: 'function', strict: false },
    strict: { type: 'boolean' },
    userInput: { type: 'boolean' }
  },
  constructor: {
    strict: { type: 'boolean' },
    strictRange: { type: 'boolean' },
    strictType: { type: 'boolean' },
    toString: { type: 'boolean' }
  },
  parse: {
    strict: { type: 'boolean' },
    strictRange: { type: 'boolean' },
    strictType: { type: 'boolean' },
    toString: { type: 'boolean' },
    userInput: { type: 'boolean' }
  }
})

// Create an instance for the base types, options, and definitions.
let instanceId = -1
const baseParser = new TypeParser({ _validated: true })
baseParser.on('error', (error) => {
  debug('%j', error)
})

// Validate the definitions.
for (const key in definitions) {
  if (Types.includes(key)) {
    baseParser._parseProperties(
      definitions[key], { strict: true, userInput: false, _key: 'definitions.' + key }
    )
  }
}

module.exports = TypeParser

debug('module loaded')
